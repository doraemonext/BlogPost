# 结构体内存对齐问题

两个法则：

* 大小为 `size` 的字段，他的结构内偏移 `offset` 需符合 `offset mod size == 0`
* 整个结构的大小必须是其中最大字段大小的整数倍

示例：

    struct Test {
        int a;     // 4
        long b;    // 8
        char c;    // 1
        short d;   // 2
    };

整个 `struct Test` 的实例大小为 24。下面来逐步分析一下：

1. `a` 本身占 4 个字节，无需调整；
2. `b` 本身占 8 个字节，根据法则 1，它的偏移位置 `offset` 需要满足 `offset mod 8 == 0`，所以 `offset` 为 8，即 `a` 的后面需要填充额外 4 个字节的 padding；
3. `c` 本身占 1 个字节，`16 mod 1 == 0`，无需调整；
4. `d` 本身占 2 个字节，根据法则 1，`offset` 需要为 `18` 才满足 `offset mod 2 == 0`，所以 `c` 的后面需要额外填充 1 个字节的 padding；
5. 根据法则 2，整个结构体中最大的字段大小为 8，所以必须为 8 的整数倍，上面所有的变量共占用 20 个字节，所以最接近的大小为 24 字节。

所以最后实例的大小为 24。

